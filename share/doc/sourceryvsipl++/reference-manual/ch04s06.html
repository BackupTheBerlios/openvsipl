<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>4.6. Selection, generation, and manipulation functions</title><link rel="stylesheet" href="cs.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"><link rel="home" href="index.html" title="Sourcery VSIPL++"><link rel="up" href="functions.html" title="Chapter 4. Function Reference"><link rel="prev" href="ch04s05.html" title="4.5. Linear System Solvers"><link rel="next" href="ch04s07.html" title="4.7. Signal Processing Functions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4.6. Selection, generation, and manipulation functions</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s05.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Function Reference</th><td width="20%" align="right"> <a accesskey="n" href="ch04s07.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id464482"></a>4.6. Selection, generation, and manipulation functions</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="functionref_generation"></a>4.6.1. Generation functions</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="functionref_rand_all"></a>4.6.1.1. Random Number Generation</h4></div></div></div><a class="indexterm" name="id464508"></a><p>This section describes the <span class="type">Rand</span> class provided by
 VSIPL++.</p><p>A <span class="type">Rand</span> object provides member functions to generate scalar
 random numbers and views of random numbers.</p><pre class="synopsis">        template &lt;typename T&gt;
        class Rand;</pre><div class="variablelist"><p class="title"><b>Template parameters</b></p><dl><dt><span class="term">T</span></dt><dd><p>The type of the random numbers generated by this class.</p></dd></dl></div><p><span class="type">Rand</span> objects may not be assigned or copied.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id464566"></a>4.6.1.1.1. Public types</h5></div></div></div><a class="indexterm" name="id464573"></a><a class="indexterm" name="id464586"></a><a class="indexterm" name="id464600"></a><pre class="synopsis">  typedef Vector&lt;T&gt; vector_type;
  typedef Matrix&lt;T&gt; matrix_type;
  typedef Tensor&lt;T&gt; tensor_type;</pre><p><b>Description: </b>These types specify the return values for the non-scalar number
   generators.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id464632"></a>4.6.1.1.2. Constructors</h5></div></div></div><a class="indexterm" name="id464638"></a><pre class="synopsis">        Rand(
          index_type seed
          index_type numprocs
          index_type id,
          bool portable = true);</pre><p><b>Requires: </b>0 &lt; <code class="varname">id</code> &lt;= <code class="varname">numprocs</code> &lt;=
   2<sup>31</sup> &#8722; 1</p><p><b>Description: </b>See [<span class="citation">VSPEC101</span>] section <span class="emphasis"><em>Random number
   generation</em></span> for more information and this quote.
   &#8220;<span class="quote">Constructs a random number generator object using the specified seed
   <code class="varname">seed</code> . If <code class="varname">portable</code> == false, the
   random number generator characteristics are implementation defined.
   Otherwise, the random number generator object obeys the VSIPL 1.1 API and
   guidelines in VSIPL 1.1 API sections &#8220;Random Numbers,&#8221; &#8220;VSIPL Random Number
   Generator Functions,&#8221; and &#8220;Sample Implementation.&#8221;</span>&#8221; When
   <code class="varname">portable</code> == <code class="constant">false</code>, the
   implementation may select an algorithm that yields performance better than
   the portable method.</p><a class="indexterm" name="id464721"></a><pre class="synopsis">        Rand(index_type seed, bool portable = true);</pre><p><b>Description: </b>Using this constructor is short-hand for using the previous
   constructor as follows:</p><pre class="programlisting">        Rand(seed, 1, 1, portable);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id464757"></a>4.6.1.1.3. Number Generators</h5></div></div></div><a class="indexterm" name="id464763"></a><a class="indexterm" name="id464777"></a><a class="indexterm" name="id464790"></a><a class="indexterm" name="id464804"></a><a class="indexterm" name="id464817"></a><a class="indexterm" name="id464831"></a><a class="indexterm" name="id464845"></a><a class="indexterm" name="id464858"></a><pre class="synopsis">        T randu()
        T randn()</pre><p><b>Description: </b>Return scalar random numbers.</p><pre class="synopsis">        const_Vector&lt;T, <span class="emphasis"><em>unspecified</em></span>&gt; randu(length_type len)
        const_Vector&lt;T, <span class="emphasis"><em>unspecified</em></span>&gt; randn(length_type len)</pre><p><b>Description: </b>Construct and return vectors of random numbers.</p><pre class="synopsis">        const_Matrix&lt;T, <span class="emphasis"><em>unspecified</em></span>&gt; randu(
            length_type rows,
            length_type columns)
        const_Matrix&lt;T, <span class="emphasis"><em>unspecified</em></span>&gt; randn(
            length_type rows,
            length_type columns)</pre><p><b>Description: </b>Construct and return matrices of random numbers.</p><pre class="synopsis">        const_Tensor&lt;T, <span class="emphasis"><em>unspecified</em></span>&gt; randu(
            length_type z,
            length_type y,
            length_type x)
        const_Tensor&lt;T, <span class="emphasis"><em>unspecified</em></span>&gt; randn(
            length_type z,
            length_type y,
            length_type x)</pre><p><b>Description: </b>Construct and return tensors of random numbers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="id464965"></a>4.6.1.1.4. Example</h5></div></div></div><pre class="programlisting">// Construct a random number generator for floats.
Rand&lt;float&gt; vgen(0, 0);

// Create a vector of 35 uniform random numbers.
Rand&lt;float&gt;::vector_type v1 = vgen.randu(35);</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id464983"></a>4.6.1.2. ramp()</h4></div></div></div><a class="indexterm" name="id464990"></a><pre class="synopsis">
    template &lt;typename T&gt;
    const_Vector&lt;T, <span class="emphasis"><em>unspecified</em></span> &gt;
    ramp(T a, T b, length_type len);
    </pre><p><b>Returns: </b>
        A Vector of size <code class="varname">len</code>.
        For <code class="code">0 &lt;= i &lt; len, w.get(i) == a + i * b</code>.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="functionref_selection"></a>4.6.2. Selection functions</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id465044"></a>4.6.2.1. first()</h4></div></div></div><a class="indexterm" name="id465050"></a><pre class="synopsis">template &lt;typename Predicate, typename Vector1, typename Vector2&gt;
index_type 
first(index_type begin, Predicate p, Vector1 v, Vector2 w);</pre><p><b>Returns: </b>
        The smallest index k &gt;= j such that
        <code class="code">f(v.get(k), w.get(k))</code>. A return value at least 
        <code class="code">v.size()</code> indicates <code class="code">f(v.get(k), w.get(k))</code>
        is <code class="constant">false</code> for all k &gt;= j.
        This value will equal <code class="code">v.size()</code> if <code class="code">j &lt; v.size()</code>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id465113"></a>4.6.2.2. indexbool()</h4></div></div></div><a class="indexterm" name="id465119"></a><pre class="synopsis">template &lt;typename VectorT&gt;
length_type 
index_bool(VectorT source, Vector&lt;Index&lt;1&gt; &gt; indices);
template &lt;typename MatrixT&gt;
length_type 
index_bool(MatrixT source, Vector&lt;Index&lt;2&gt; &gt; indices);
template &lt;typename TensorT&gt;
length_type 
index_bool(TensorT source, Vector&lt;Index&lt;3&gt; &gt; indices);</pre><p><b>Description: </b> 
        Obtain all indices for which <code class="varname">source</code> evaluates to 
        <code class="constant">true</code>, in lexicographical order.
      </p><p><b>Returns: </b>The number of elements returned.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id465172"></a>4.6.2.3. gather()</h4></div></div></div><a class="indexterm" name="id465178"></a><pre class="synopsis">template &lt;typename T, typename B0, typename B1&gt;
Vector&lt;T, <span class="emphasis"><em>unspecified</em></span> &gt;
gather(const_Vector&lt;T, B0&gt; source, Vector&lt;Index&lt;1&gt;, B1&gt; indices);
template &lt;typename T, typename B0, typename B1&gt;
Vector&lt;T, <span class="emphasis"><em>unspecified</em></span> &gt;
gather(const_Matrix&lt;T, B0&gt; source, Vector&lt;Index&lt;2&gt;, B1&gt; indices);
template &lt;typename T, typename B0, typename B1&gt;
Vector&lt;T, <span class="emphasis"><em>unspecified</em></span> &gt;
gather(const_Tensor&lt;T, B0&gt; source, Vector&lt;Index&lt;3&gt;, B1&gt; indices);</pre><p><b>Description: </b> 
        Returns value from <code class="varname">source</code>, at positions given by <code class="varname">indices</code>.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id465230"></a>4.6.2.4. scatter()</h4></div></div></div><a class="indexterm" name="id465236"></a><pre class="synopsis">template &lt;typename T, typename B0, typename B1, typename B2&gt;
void
scatter(const_Vector&lt;T, B0&gt; source,
        Vector&lt;Index&lt;1&gt;, B1&gt; indices,
        Vector&lt;T, B1&gt; destination);
template &lt;typename T, typename B0, typename B1, typename B2&gt;
void
scatter(const_Vector&lt;T, B0&gt; source,
        Vector&lt;Index&lt;2&gt;, B1&gt; indices,
        Matrix&lt;T, B1&gt; destination);
template &lt;typename T, typename B0, typename B1, typename B2&gt;
void
scatter(const_Vector&lt;T, B0&gt; source,
        Vector&lt;Index&lt;3&gt;, B1&gt; indices,
        Tensor&lt;T, B1&gt; destination);</pre><p><b>Description: </b>Copies all values from <code class="varname">source</code> into
        <code class="varname">destination</code>, at the index given by <code class="varname">indices</code>.
      </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s05.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04s07.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4.5. Linear System Solvers </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 4.7. Signal Processing Functions</td></tr></table></div></body></html>
